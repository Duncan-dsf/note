## JMM

1. 主内存和工作内存
   1. 主内存
      1. 包括：实例字段、静态字段、和构成数组对象的元素；但不包括局部变量和方法参数，因为他们是线程私有的
      2. 所有变量都存储在主内存
   2. 工作内存是线程使用到的变量的主内存的副本，线程对变量的操作必须在工作内存中进行
2. 内存交互操作
   1. lock
   2. unlock
   3. read
   4. load
   5. use
   6. assign
   7. store
   8. write
3. 操作规则：

## volatile ——jvm P362-jmm

1. 变量定义为volatile之后具备两种特性 ：
   1. 保证变量对所有线程的可见性 不保证原子性
   2. 禁止指令重排
2. 实现：
   1. 可见性 ：在对volatile变量赋值之后，会多执行一个lock语句，使得本cpu的cache写入内存，写入操作会使别的cpu无效化其cache，需要使用该变量时，需要重写从主存读取，进而实现可见性
   2. 禁止指令重排 ：lock使本cpu的cache写入内存，需要保证lock前的操作执行完毕（因为指令重排不能影响程序运行结果），所以可以保证lock前的操作发生在lock后的操作前。
3. volatile 规则：
   1. 使用变量前，需要从主存刷新，保证可以看到其他线程的修改
   2. 修改变量后，立即写回主存，保证可以让其他线程看到
   3. 禁止指令重排 （原文《深入理解jvm》P372 我看不懂）
4. 针对64位基本类型——long, double，允许jvm不保证其load, store, read, write操作的原子性。

## 原子性，可见性，有序性

——jmm是围绕这并发过程中如何处理这三个特性建立起来的，以下是哪些操作可以实现三个特性

1. 原子性
   1. 定义
   2. 实现：jmm层次：lock，unlock；字节码指令monitorenter，monitorexit；关键字synchronized
2. 可见性
   1. 定义
   2. 实现：volatile，synchronized，final
      1. synchronized 使用lock和unlock实现 unlock之前须将变量写回内存
      2. final 假如this引用未逃逸（this引用逃逸可能使其他线程访问到初始化了一半的对象），final因为不可变所以工作内存中的副本和主存相同，可以保证可见性
3. 有序性
   1. 定义 
   2. 实现 
      1. volatile禁止指令重排 
      2. synchronized 变量同时只允许一条线程lock，而单一线程的所有操作尽管会重排序，但不影响结果，可以认为有序。

## 先行发生原则

1. 程序次序规则：一个线程内，按按照代码顺序执行

2. 管程锁定规则：同一个锁的unlock先行与后面的lock

3. volatile变量规则：对volatile变量的写操作先行发生与后面的读操作

4. 线程启动规则：thread的start方法先行发生于此线程的每一个动作

5. 线程终止规则：线程的所有操作都先行发生于对此线程的终止检测

6. 线程中断规则：对线程的interrupt操作先行发生于检测到线程中断的发生

7. 对象终结规则：对象的初始化完成先行于它的finalize的开始

8. 传递性：A先于B，B先于C ，则A先于C

## 线程安全级别

安全程度从强到弱：不可变 绝对线程安全 相对线程安全 线程兼容 线程对立

1. 不可变 不可变的对象一定是线程安全的（前提this引用没有逃逸）
   1. 基本类型只要定义未final，就可以保证不可变
   2. 如果是**引用类型**，需要保证对象的状态不会受对象行为影响；所以引用类型的不安全在于可能线程一判断某对象状态后，另一线程进行了改变。
   3. 符合不可变要求的类型：String、Number的子类：Integer、Long、Short、、、（除BigInteger、BigDecimal等由数组存储的值和AtomicInteger、AtomicLong类型）
2. 绝对线程安全： 任何情况下，调用者不需要任何同步措施，仍可以安全运行。很难实现，jdk提供的类也大多不是绝对线程安全。（不可变一定是绝对线程安全）
3. 相对线程安全：通常意义上的线程安全——对某个对象的单独的操作是线程安全的。
4. 线程兼容：大多数jdk的api都是这样——调用端正确使用同步可以保证线程安全
5. 线程对立：不管采用什么同步措施，都会线程不安全；例如：
   1. Thread.suspend和Thread.resume 两线程同时对另一线程分别调用这两个方法必定产生死锁
   2. 原因：suspend停止不释放资源，当另一线程resume之前锁定已被锁定资源，必定产生死锁

## 线程安全实现方法

1. 互斥同步/阻塞同步：互斥是方法，同步是目的；最大的问题：线程阻塞和唤醒带来的性能问题
   1. 互斥实现方法：
      1. 临界区（CriticalSection）
      2. 信号量（Semphore）
      3. 互斥量（Mutex）
   2. java中的实现方法：
      1. synchronized：
         1. 同步代码块编译之后，代码块前后会出现moniterenter和moniterexit的字节码指令，这两个命令需要引用类型的参数来指明需要锁定和解锁的对象
         2. （**为什么不能锁基本类型嘞？？**）加锁是为了保证只有一个线程可以访问该变量，进而实现同步，但是基本类型可以直接final不需要多此一举。编译器报错——需要Object类型而不是int类型
         3. 如果synchronized修饰方法：实例方法锁定实例、类方法锁定类对象
         4. 执行moniterenter时首先尝试获取锁，如果当前无锁或者锁的拥有者是当前线程，锁的计数器加一，否则当前线程等待直到对象锁被释放
         5. synchronized重量锁：阻塞或唤醒线程需要从用户态到内核态
         6. synchronized 可重入
         7. 优化 ： 自旋锁，循环判断是否锁被释放，假如锁被释放了，就不需要阻塞线程，不浪费cpu时间
      2. reentryLock：基本用法和synchronized相同，还增加了些高级功能：
         1. 等待可中断
         2. 公平非公平（synchronized的是否公平？**非公平**）
         3. 锁可以绑定多个条件 new Condition之后await阻塞，signalAll打断
2. 非阻塞同步：乐观的并发策略，先进性操作，如果没有其他线程争用，则操作成功，如果操作失败，需要进行补救（比如不断重试）；
   1. 这种实现需要硬件的支持：因为冲突检测和操作需要原子性，这类指令有：CAS（其余的P394）
3. 无同步方案 假如一个方法本来就不涉及共享数据，那它就无须任何同步
   1. 可重入代码    共同特征：
      1. 不依赖存储在堆上的数据和公用的系统资源、用到的状态变量都由参数传入、不调用非可重入的方法等
      2. 判断方法：如果一个方法的返回结果可预测——只要输入了相同的树，就能返回相同的结果，那就满足可重入性，也就线程安全
   2. 线程本地存储：如果一个代码需要的数据必须与其他代码共享，假如这些共享数据的代码可以在同一线程内运行，那么就无须同步也可以保证线程之间不出现数据争用问题。java中的ThreadLocal

## 锁优化

1. 自旋锁和自适应锁：

   1. 共享数据的锁定短的话，挂起和恢复线程并不值得，当遇到共享数据被锁定时，先不放弃cpu执行时间，等待看看持有锁的线程释放很快释放锁；为了让线程等待，我们只需让线程执行一个忙循环（空循环，自旋），这就是自旋锁
   2. 而假如锁定时间长的话，忙等待需要占用的时间浪费，因此自旋的等待时间有限度，如果自旋超过限定次数仍然没有获取锁，则需要使用传统的方式挂起线程
   3. jdk1.6默认开启自旋锁，自旋次数默认是10次，用户可以用-XX:PreBlockSpin更改
   4. 1.6也引入了自适应的自旋锁，自旋时间不再固定而是基于上次在同一锁的自旋时间及锁的拥有状态决定：如果上一次自旋成功获得了锁，且持有锁的线程还在运行，那么虚拟机会认为此次自旋也很有可能获取锁，进而运行自旋等待更长的时间，比如100次循环；如果某个锁，自旋很少成功，那么以后获取这个锁时，可能省略自旋过程

2. 锁消除：虚拟机即时编译器在运行时，对一些代码上要求同步，但是检测到不可能存在共享数据竞争的锁进行消除。锁消除的依据主要来自逃逸分析，如果在一段代码中，堆上所有数据都不逃逸出去，那么可以把它们当成栈的数据，当成线程私有的，无需线程同步；可能不是程序员用的同步，而是调用同步的方法或者jvm自动优化产生的多余同步

3. 锁粗化：假如在一系列连续操作中对同一对象反复的加锁和解锁，频繁的互斥同步操作会导致不必要的性能消耗，虚拟机检测到这种情况会将加锁同步的范围扩张到整个操作序列之外

4. 轻量锁：

   1. MarkWord是对象头的一部分（另一部分存放指向方法区对象类型的指针，如果是数组，还有数组长度），MarkWord在对象的不同状态下会存储不同的数据，但都会保留标志位，但是值不同：未锁定时Mark Word包括三部分——对象哈希码、分代年龄、标志位此时值位01；

      |存储内容|标志位|状态|
      | :-:    | :-:    |:-: |
      |哈希码、分代年龄| 01 | 未锁定 |
      | 指向锁记录的指针 | 00 | 轻量锁 |
      |指向重量锁的指针|10|重量锁|
      |空，不记录信息|11|gc标记|
      |偏向线程ID、偏向时间戳、对象分代年龄|01|可偏向|

   2. 轻量锁执行过程：

      1. 假如当前对象无锁，先将MarkWord拷贝一份存在当前线程的栈帧中，同时将MarkWord的值CAS为指向MarkWord在当前线程拷贝的指针，CAS成功则表示当前线程拥有了轻量锁。
      2. 如果CAS失败，说明有线程争用，那么轻量锁要膨胀为重量锁，锁标志变为10，MarkWord的值变为指向重量锁的指针；
      3. **重量锁时的对象头信息（Hash、age）放哪呢？ 存放在重量锁中**

5. 偏向锁：

   1. 偏向锁会偏向第一次获得锁的线程，如果接下来没有其他线程获取，则持有偏向锁的线程访问临界区不再需要同步，例如：lock、unlock、对MarkWord的update（**那轻量锁呢 既然说偏向锁不需要 言外之意就是轻量锁和重量锁需要 否则偏向锁凭什么和这两种锁区分开**）
   2. 执行过程：
      1. 对象第一次被线程获取时，将锁标志设为01，CAS将当前线程的id记录在MarkWord中，设置成功后，这个线程再进入这个锁相关的同步块时，不再进行任何同步操作。
      2.  **那么 此时的Hash、age存放在哪呢**：
         1. 当一个对象已经计算过identity hash code，它就无法进入偏向锁状态；
         2. 当一个对象当前正处于偏向锁状态，并且需要计算其identity hash code的话，则它的偏向锁会被撤销，并且锁会膨胀为重量锁；
         3. 重量锁的实现中，ObjectMonitor类里有字段可以记录非加锁状态下的mark word，其中可以存储identity hash code的值。或者简单说就是重量锁可以存下identity hash code。


