## C3

### 练习题3.1

> 3.4.1操作数指示符 P122

| 操作数          | 值    |
| --------------- | ----- |
| %rax            | 0x100 |
| 0x104           | 0xAB  |
| $0x108          | 0x108 |
| (%rax)          | 0xFF  |
| 4(%rax)         | 0xAB  |
| 9(%rax, %rdx)   | 0x11  |
| 260(%rcx, %rdx) | 0x13  |
| 0xFC(, %rcx, 4) | 0xFF  |
| (%rax, %rdx, 4) | 0x11  |

全对

### 练习题3.2

> 3.4.2数据传送指令 p124

|我的答案|操作数|正确答案|
|----|---- |----|
|movlq | %eax, (%rsp) |movl|
|movw | (%rax) %dx|√|
|movb | $0xFF, %bl|√|
|movb | (%rsp, %rdx, 4), %dl|√|
|movq | (%rdx), %rax|√|
|movq | %dx, (%rax)|movw|

蒙对的几个

**指令的寄存器操作数的大小必须与指令的最后一个字符（b，w，l，q）大小匹配**——P122最下面那句话。

### 练习题3.3

> 3.4.2数据传送指令 p125

> 汇编器将汇编代码变成目标代码（二进制）

| 指令                 | 错误原因                                                     | 改正                                 |
| -------------------- | ------------------------------------------------------------ | ------------------------------------ |
| movb $0xF (%ebx)     | 基址和变址寄存器必须是64位——参见P121 C3.4.1的第三段话        |                                      |
| movl %rax, (%rsp)    | 寄存器的大小和指令匹配                                       | movq                                 |
| movw (%rax), 4(%rsp) | mov指令不允许内存与内存传送                                  | 分两步，movq 内存 ,%r; movq %r, 内存 |
| movb %al, %sl        | 没有%sl这个寄存器                                            |                                      |
| movq %rax, %0x123    | 立即数无法作为目的                                           |                                      |
| movl %eax, %rdx      | 大小不匹配，movl尽管可以实现l->q,但是那是隐含结果，操作数依旧需要都是l |                                      |
| movb %si, 8(%rbp)    | 寄存器的大小和指令匹配                                       | movw                                 |

### 练习题3.4

> C3.4.3 数据传送示例 P126

| src_t          | des_t          | 指令                                   |
| -------------- | -------------- | -------------------------------------- |
| long           | long           | movq (%rdi), %rax; movq %rax, (%rsi)   |
| char           | int            | movsbl (%rdi), %eax; movl %eax, (%rsi) |
| char           | unsigned       | movzbl (%rdi), %eax; movl %eax, (%rsi) |
| unsigned char | long           | movzbq (%rdi), %rax; movq %rax, (%rsi) |
| int            | char           | movb (%rdi), %al; movb %al, (%rsi)     |
| unsigned       | unsigned char | movb (%rdi), %al; movb %al, (%rsi) |
| char | short | movsbw (%rdi) %ax; movw %ax, (%rsi) |

- 扩展数字参见C2.2.6 截断数字参见C2.2.7——P54
- 扩展的情况下，内存-->%rax，需要先进行movs即符号扩展，**因为mov在操作数是1 2字节情况下不会改变高位的值**，**之后再进行扩展的时候可能带上原有的高位值的影响**
- 截断的情况下，不管是有无符号，直接截断位就可以
  - 答案是**先将源值内存-->%rax，直接取%al等低位值到内存**——%r中可以保存源值
  - 另一种可行方式：**直接用movb方式将大的源值放到%al, 之后在%al-->内存**——修改汇编代码并继续编译发现可以运行。