> 计算机网络——自顶向下

## 运输层

### 概述

- 运输层协议为运行在不同主机上的进程提供了**逻辑通信**：

  - 从应用层看，通过逻辑通信运行不同进程的主机就像直接相连

- 运输层协议是在**端系统**而不是在网络路由器中实现的
  - 发送方：运输层将接收到**应用进程的报文**转换成**运输层分组**（运输层报文**segment**）（将应用层报文划分成较小的快，并为每块加上运输层首部来创建运输层报文）
  - 然后在发送方端系统，运输层将这些报文段传递给网络层，网络层将其封装成网络层分组（数据报）并向目的地发送
  - 网络路由器仅作用与该数据报的网络层字段，不检查封装在该数据报的运输层报文段的字段
  - 接收方：网络层从**数据报中提取运输层报文段**。并将改报文段想上交给运输层
  - 运输层则处理接受到的报文段，传给应用层

- 运输层与网络层关系
  - 运输层为运行在不同主机上的进程提供逻辑通信
  - 网络层提供了主机之间的逻辑通信

- 因特网运输层概述

  - 运输层基于网络层ip协议
    - ip提供主机间逻辑通信
    - 服务模型是尽力交付服务：
      - ip尽最大努力在主机间交付报文段，但他并不做任何确保
      - **不确保报文段交付**、**不保证报文段按序交付**、**不保证报文段中数据完整性**

  - 协议
    - udp（用户数据报协议）：不可靠、无连接的服务
    - tcp（传输控制协议）：可靠、面向连接的服务
    - 开发人员需要指定两种运输层协议的哪一种
    - 运输层分组的命名：
      - 运输层报文段（udp和tcp）统称为**报文段（segment）**
      - 网络层分组统称**数据报datagrama**
  - tcp/udp的**基本任务**
    - 将两个端系统间的交付服务扩展为运行在两个端系统上的进程间的交付服务
      - 将主机交付扩展到进程交付称为**运输层的多路复用和多路分解**
    - 通过在其报文段的首部添加**差错检测字段**而提供完整性检查
      - **进程间数据交付**和**差错检测**是两种最低限度的运输层服务
      - **也就是udp提供的服务**
        - udp也是不可靠服务
      - tcp：
        - 提供可靠数据传输：通过流量控制、序号、确认和定时器
        - 拥塞控制
          - 与其说是提供给调用它的应用程序的，不如说是提供给整个因特网的
          - tcp拥塞控制防止任何一条tcp链接用过多流量来淹没通信主机之间的链路和交换设备
          - tcp允许tcp链接通过一条拥塞的网络链接，平等的共享网络链路带宽
          - 这可以通过提哦啊接发送方tcp发送到网络的流量的速率实现
          - 而udp的流量是不可调节的，使用udp的应用可以根据其需要以任何速率发送数据

### 多路复用和多路分解

#### 套接字

- 进程有一个或多个套接字，它相当于从网络向进程传递数据和从进程向网络传递数据的门户
- 接收主机中的运输层实际并没有直接将数据交付给进程，而是**通过一个中间的套接字来传递**（socket位于**应用与运输层之间**）
- 由于在任何一个时刻接受主机上可能有多个套接字，所以每个套接字都有一个**唯一标志符**，标志符的**格式取决于是udp还是tcp**（P128）![](pic/端口.png)
  - 唯一标志符就是**端口号**
  - 主机上的每个套接字会被分配一个端口号
  - 端口号是一个16比特的数字
    - 大小为0-65535
    - 0-1023为周知端口号，保留给周知应用层协议的
  - tcp与udp的端口是独立的，
    - tcp端口有65536个，udp也是这样，
    - tcp有80端口 udp也有80
  - 端口扫描nmap

#### 复用/分解

- 定义
  - 运输层报文段中设置**几个字段**，在接收端，运输层检查这些字段，并**标识出接收套接字**然后将报文段定向到该套接字
  - 将运输层报文段中的数据交付到正确的套接字的工作叫**多路分解**
  - 从源主机不同的套接字中收集数据块，并为**每个数据块封装上首部信息**（这将在多路分解时使用）从而生成报文段，然后将报文段传递到网络的工作，称为**多路复用**
- 实现
  - 实现要求
    - 套接字有唯一的标志符（标志端口的同时，需要标志tcp还是udp）
    - 每个报文段有**特殊字段**来指示该报文段所要交付的套接字
      - 源端口号字段
      - 目的端口号字段
  - 实现
    - 主机为每个套接字分配一个端口号，当报文段到达时，运输层检查报文段中的目的端口号，并将其定向到相应的套接字，然后报文段中的数据通过淘吉庄进入其所连接的进程
    - udp：无连接的多路复用/分解
      - java代码new DatagramSocket();创建udp套接字时，运输层自动为该套接字分配一个**1024-65535的尚未被使用**的udp端口
      - new DatagramSocket(11111);可以主动为套接字指定端口，如果是实现**周知协议的服务端**，那么就必须为其分配一个相应的周知端口
      - upd套接字由一个包含**目的IP地址**和**目的端口号**的**二元组**全面标志
        - 两个udp报文段有不同的源ip、端口，却具有相同的目的ip、端口，那么两个报文段将通过同一套接字定向到相同的目的进程
        - 只靠端口无法标识，因为不同目的ip有同样的端口
    - tcp：面向连接的多路复用/分解
      - tcp套接字由**四元组**标识（源ip，源端口。目的ip，目的端口）
      - 当一个tcp报文段从网络到达一台主机时，主机使用全部4个值来将报文段定向到相应的套接字
      - 与udp不同，两个具有不同源ip地址或源端口号到达的tcp报文段被定向到两个不同的套接字（tcp udp报文 **具体怎么定向**到不同的socket）
        - serverSocket绑定端口
        - 每有一个目的端口是此端口的请求，会被serverSocket accept，建立一个socket，接受当前请求的源ip的请求
        - 新建的socket以四元组标识，之后接收到的报文段如果四元组匹配，就会被多路分解到这个套接字
        - 这样客户端和服务端就可以互发数据了
      - 服务端主机可以同时支持很多tcp套接字，每个套接字与一个进程相联系（不一定accept新建socket需要新建进程，由serversocket进程处理即可），由四元组标识每个套接字（**四元组只能标识socket**，而不能标识serversocket（**java中存在**）**serversocket 是socket吗**）（serversocket怎么实现）
      - web服务器与tcp
        - 在一台运行web服务的主机，在80端口运行着一个apache服务器，当客户端向服务器发送报文段时，所有报文段的目的端口都是80
        - 服务端可以为每个连接产生一个新进程
          - 每个套接字可以属于不同的进程
        - 而今高性能的web服务器通常只使用一个进程，但是为每个连接新建一个具有新连接套接字的新线程
        - 持久性http则在整个连接持续时间内，客户端和服务器之间经由同一个服务器套接字交换thhp报文
        - 而如果使用非持久http，则对每一对请求/响应都需要一个新的tcp连接被创建，请求/相应完成后随即被关闭，这种频繁的创建和关闭套接字会严重的影响一个繁忙的web服务器性能

### udp

#### 概述

- udp只提供必要的运输层功能
  - 多路复用/分解
  - 差错检测

- 使用udp时，应用开发人员几乎是直接和ip打交道
  - udp从应用进程拿到数据，附上多路复用/分解所需的目的端口和源端口（**源端口有什么用？ 接收方可以返回数据回来吗 可以的 接收方接收到报文段 可以获取到发送地址**）（详见网络编程-udp），以及**其他两个小字段**，然后形成报文段交付给网络层
  - 网络层将报文段封装到一个ip数据报，而后尽力而为地交付目的主机
  - 如果该报文段到达目的主机，则udp将报文段发到目的端口的socket，应用层处理

- UDP应用：DNS
  - DNS构造一个查询报文并交给UDP
  - 无需握手，UDP为报文添加首部，封装成报文段，并交付网络层
  - 网络层将报文段封装成数据报，发送给域名服务区
  - 如果没有响应，尝试另一个域名服务器，或者通知调用程序

- udp优点：

  - 应用层能更好的控制要发送的数据和发送的时间
    - 只要应用层将报文传递给udp，udp就会将报文打包成报文段并立即将其传递给网络层
    - tcp拥塞控制在源和目的主机间的链路变得非常拥塞时，遏制运输层tcp发送方，tcp任继续发送直到目的主机收到此报文段并加以确认，而不管可靠交付时间要用多久
    - 实时应用通常要求最快的发送速率，并不想过分的延迟报文段的传递，且能容忍一些数据丢失
  - 无需连接建立
    - 无需三次握手，没有建立连接的时延（DNS基于udp的主要原因）
  - 无连接状态
    - tcp需要在端系统维护链接状态
    - 连接状态包括
      - 发送和接收缓存
      - 拥塞控制参数
      - 序列号和确认号
    - 开销大
  - 分组首部小
    - tcp报文段有20字节的首部开销
    - udp仅有8字节

- 因特网应用及其使用协议：

  ​	![](pic/网络应用及其使用协议.png)

- 使用udp的应用是可以实现可靠数据传输的

  - 需要在应用自身简历可靠机制完成（增加确认和重传机制）
  - 这样既可以拿到udp的优势（没有拥塞控制），又可以实现可靠传输

#### udp报文结构

- 两部分：
  - udp首部，共4个字段，每个字段2字节
    - 源端口
    - 目的端口
    - 长度：udp报文段的长度
    - 检验和：**保证udp单个报文段完整性（无缺无错有序）**（udp的不可靠在于一个个的报文段可能出现丢失，无序到达）（所以确认和重传机制可以实现可靠）
      - **检查和的计算** （P136）
  - 应用数据（报文）

### 可靠数据传输原理

#### 需要解决3个问题

- **每个报文段传输正确**
- **报文段不能丢失**
- **报文段有序接收**

#### 自动重传请求ARQ

（**Automatic Repeat reQuest**）这是基于重传的可靠数据传输协议（C3.4）

它需要四种协议来实现可靠传输

- 差错检测：首先需要一种机制可以使接收方**检查到何时出现了比特差错**
- 接收方反馈：发送方和接收方在不同端系统，发送方需要了解接收方的情况，所以接收方需要提供明确的**反馈信息**给发送方（**ACK/NAK 确认和否定确认**）
- 重传：接收方收到有差错的分组时，向发送方反馈，发送方**重传该分组**
- 序列号：考虑到网络的不稳定，分组不一定顺序到达，且无法分辨哪个为重传分组，所以需要为每个分组加序列号

##### 停等协议

在等待接收方反馈时，发送方不会发送一块新数据，直到确认接受方正确接收当前分组

##### 丢包问题

- 如何判断是否丢包
  - 发送方需要等待一段时间，还是没有响应，便可认为组分已丢失，重传分组
  - 那么需要等待多久呢
    - 发送方与接收方的一个往返时延
    - 接收方处理分组的时间
    - 一个最坏情况下时延是很难估计的，因为有很多不确定因素，而且假如等待最大时延，那么发现丢包需要很长时间。
    - 所以需要等待一个合适的时间后重传分组
    - 但这样有可能出现**之前认为丢失的分组**和**重传分组**都到达接收方的情况，这就是**冗余数据分组**（可由序列号判断）
    - 等待时间的实现需要**倒计数定时器**，在给定时间过期后，中断发送方，发送方开始重传分组
      - 发送方每次发送一个分组时，便启动一个定时器（**性能是不是很差 流水线实现性能更好**）
      - 响应定时器中断，采取适当动作
      - 终止定时器

### 流水线可靠数据传输

上面的实现是一个**停等协议**，传输速度太差

解决办法

- 不使用停等协议，允许发送方发送多个分组而**无需等待确认**，像是不断向一条流水线填充分组，所以称为**流水线**技术，实现要求
  - 必须增加序号范围
  - 协议的发送方和接收方需要缓存多个分组
    - 发送方需要缓存已发送未确认的分组
    - 接收方需要缓存已正确接收分组（缓存完成之后可以直接写到连续内存中）
  - 分组丢失的处理
    - 回退N步 （GoBack N ——GBN）
    - 选择重传

### GBN/滑动窗口

允许发送方发送多个分组而无需等待确认，但它也受限于在流水线中未被确认的分组数不能超过某个**最大允许数N**

- base：**最早未确认的分组的序号**（发出去之后接收方未确认收到）
- nextSeqNum：**下一个待发送的分组的序号**

所以base、nextSeqNum、N可以将序号范围分成4部分

- [0, base-1]已发送并确认的分组
- [base, nextSeqNum-1]已发送但未确认（可能这个范围内有分组被确认，但base未被确认，所以base无法向后推进）
- [nextSeqNum, base+N-1]可发送，但尚未发送的
- [base+N, +&infin;)，不能直接使用，直到base向后推进

窗口：

- 上面的4个部分中[base, nextSeqNum-1]、[nextSeqNum, base+N-1]合在一起就是窗口，随着协议的进行，窗口在序号空间内滑动，N是窗口长度，GBN协议常被称为滑动窗口协议
- 为什么需要限制窗口大小为N
  - 流量控制：防止接收方缓存溢出
  - 拥塞控制：防止网络中的链路出现拥塞
- 发送方需要响应一下三种事件
  - 上层的调用
    - 当上层想要发送数据时，检测窗口已满，即是否有N个已发送但未确认的分组
    - 窗口未满。则创建分组并发送，更新相应变量
    - 已满，
      - 发送方可能将**数据返回上层**，隐式通知上层该窗口已满，上层可能过一会重试
      - 实际实现时，**发送方更可能缓存报文**（可发送时再发送），**或使用同步机制（信号量或标志）**，允许上层**仅在窗口不满的时候**，调用发送报文的方法
  - 收到ACK：GBN采用积累确认（cumulative acknowledgment），假如n之前所有的分组被确认，base才可以推进到n
  - 超时事件：如果超时（**计时器怎么设置 一个计时器如何实现**），发送方重传所有已发送但未确认的分组
    - 发送方仅使用一个定时器，它可以被当成最早的已发送但未被确认的分组所使用的定时器
    - 如果收到一个ACK，但仍有已发送但未确认的分组，定时器重新启动（**收到就重新启动计时器吗**）（**合理解释：收到一个ACK，如果是base位的ACK，那么重启计时器**）
    - 如果没有已发送但未确认的分组，则定时器被终止(**当有分组被发送时，启动计时器**)
- 接收方的动作
  - 如果接收到需要为n的分组
    - 如果分组n按序（**n-1之前的分组全部被正确接受**），那么接收方为分组n发送一个ACK，并将该分组的数据交付到上层
    - 否则，丢弃（**所有失序的分组**），并为**最近一个按序接受的分组重传ACK**（提醒发送方重传下一个分组）
    - 这种实现优点是接收方缓存简单，保存的变量少（**只需一个expectedSeqNum**）
    - 缺点：丢弃一个正确接收的分组，需要重传，重传也可能出错或丢失，可能引发更多的重传，**导致重传大量没必要重传的分组**
    - **这方法有病吧**（不是真正使用的方法）

### 选择重传/SR

选择重传通过让发送发仅重传那些它怀疑在接收方出错（丢失或受损）的分组，而避免了不必要的重传

- 个别的、按需的重传，要求接收方逐个地确认正确接收的分组
- 使用窗口长度N来限制流水线中未完成、未被确认的分组数
- 发送端需要知道哪些分组超时了

SR发送方的动作

- 从上层收到数据
  - 收到上层的数据后，SR发送方检查下一个可发送的分组序号
  - 如果在窗口内，那么数据打包并发送
  - 否则要么将数据缓存，要么将其返回给上层
- 超时
  - 每个分组必须拥有自己的逻辑定时器（假如**只有一个定时器给base位计时**，那么可能会出现窗口内部的某一个分组**刚被发送还没被接收方接收便重传**）
  - 当某个定时器超时，重新发送定时器对应的分组，也就是超时后只能发送一个分组。可以使用单个硬件定时器模拟多个逻辑定时器的操作（也许当发送时，保存一个发送时间T，当计时器为T+X的时候，表示超时）
- 收到ACK。
  - 如果收到ACK，且序号在窗口内，发送方将被确认的分组标记为已接收，停止计时器
  - 如果ACK等于base，则base推进到最小尚未被确认分组处
  - 如果窗口移动了，且窗口内有未发送分组，则发送这些分组

SR接收方动作

- 序号在[base, base+N-1]内的分组被正确接收
  - 返回ACK（**GBN是返回按序接收的最大的序号，SR呢？**）
    - 计算机网络（谢希仁）P226 ![](pic/选择确认.png)
    - 选择重传需要发送方知道哪些分组已被接收
      - 单纯的确认无法实现，确认只能确定ack之前的一段被接收，但不知道这一段有多长
      - 比如：报文段①序号10，②序号20，长度皆为10，接收方接收到②返回确认20，那么发送方并不知道①有没有被接收
      - 实现由两种
        - 选择确认，在tcp首部选项添加字段，描述被接收的报文段的序号的左右界
        - 发送方维护更多状态变量：每个报文段的序号的左右界，那么收到接收方确认时，可以知道确认的是那块窗口内的数据
      - 实现麻烦
  - 如果之前没有接受过，缓存到接收缓存
  - 如果序号等于base，将base及之后的连续分组交付上层，base推进到最小的未接收的分组处
- 序号在[base-N, base-1]内的分组被正确接收
  - 产生一个ACK，重新确认
  - 有可能发送方send_base在[base-N, base-1]之间，假如接收方不发送确认，send_base可能永远无法推进
  - ![](pic/SR.png)
- 其他情况忽略该分组

### TCP

#### TCP连接概述

tcp特性

- tcp是面向连接的，因为在应用进程可以开始向另一个应用进程发送数据前，**需要互相握手**

- 即必须相互发送某些**预备报文段**，以建立确保数据传输所需的参数，连接双方都将初始化与tcp连接相关的许多**tcp状态变量**
- tcp协议只在端系统中运行，所以**网络的中间元素**（路由器和链路层交换机），不会**维持tcp连接状态**（中间网络元素对tcp连接完全不知情，他们看到的是数据）
- tcp连接提供的是**全双工服务**
  - 进程A与进程B通过tcp连接，那么应用层数据可以从A流向B的同时，从B流向A
- tcp连接也是**点对点**的
  - tcp是单个发送方与单个接收方的连接
  - “多播”是指在**一次发送操作中**，从一个发送方将数据传递给多个接收方，对tcp来说，这是**不可能的**

连接是怎样建立的

- 发起连接的进程是**客户机进程**，另一个进程叫**服务器进程**
- 客户机进程先通知客户机运输层，他想与服务器上的一个进程建立连接
- java的代码：Socket socket = new Socket("hostname", port);
- 这样客户机运输层就和服务器运输层建立了连接
  - 客户机首先发送一个特殊的tcp报文段
  - 服务器用另一个特殊的tcp报文段来响应
  - 客户端再用第三个报文段作为响应
  - 前两个报文段**不承载有效载荷**，也即是不包含应用层数据，而第三个可以承载数据。
  - 因为客户端和服务器之前发送了三个报文段，所以这个连接建立过程被称为**三次握手**

连接建立之后就可以互发数据

- 客户机通过套接字（该进程的门户）传递数据流，一旦数据通过该门户，它就由tcp控制了
- tcp将这些数据引导到该连接的**发送缓存（send buffer 是在三次握手哪一次建立？）**，tcp会在适时的时候从发送缓存里取出一块数据。
- 取出数据的大小受限于**最大报文段长度（maximum segment size, MSS，应用数据的长度，不包括tcp首部）**，mss根据最初确定的**最大链路层帧长度**（**最大传输单元 MTU**）来设置
- tcp将每块客户机数据加一个tcp首部，从而形成多个**tcp报文段**，并下传到网络层
- 网络层将其分别封装到ip**数据报**中，数据报被发送到网络中
- 当tcp在另一端接收到一个报文段之后，该报文段就被放入该tcp连接的**接收缓存**中，应用程序可以从接收缓存中读取数据流

tcp连接的组成

- 客户机的缓存、变量、与客户进程连接的套接字
- 服务器的缓存、变量、与服务进程连接的套接字

#### tcp报文结构

- 数据字段：应用数据（报文）MSS就是这个字段的最大长度
- 首部：通常20字节大小（无选项字段的情况下）
  - ![](pic/tcp首部.png)
  - **udp有的且tcp有的：源端口、目的端口、检验和每个字段2字节**（**没有长度，只有首部长度**）
  - udp没有的：
    - **序号（seq）**：32bit
      - 序号是建立在**字节流**之上的，序号是**数据字段部分第一个字节**的序号，而不是当前报文段的序号
      - tcp的双方都可以随机选择初始序号，这样可以减少哪些仍在网络中的来自两台主机之间的先前已终止的连接的报文段，被误认为是当前有效的报文段
    - **确认（ack）**：32bit
      - 期望收到对方下一个报文段的第一个**数据字节的序号**
    - 可选与变长的**选项字段**，(P157)
    - 4bit的**首部长度（单位是32bit）**，由于tcp的选项字段，所以tcp首部长度是可变的。**首部最大60字节**，通常一般tcp选项字段为空，所以**tcp首部长度一般20字节**
    - 6bit的**标志字段**
      - ACK：用来指示**确认字段**中的值是有效的
      - **RST、SYN、FIN 用于连接建立、拆除的**
      - URG、PSH：紧急数据（实际中并没有使用）
    - 6bit的**保留字段**：保留为今后使用，目前应置为0
    - 16bit的**接收窗口**，用于流量控制，指示接收方愿意接收的字节数量
    - 16bit的**紧急指针**：紧急数据指针字段指出紧急数据的最后一个字节

#### 往返时延的估计和超时

tcp采用**超时重传机制**处理**报文段丢失**问题

超时重传最明显的需要解决的问题：超时间隔的长度

- 超时间隔需要大于tcp连接的**往返时延（RTT round trip time）**，即一个报文段从发送到收到接收方的确认的时间，否则会造成不必要的重传，那么这个时间是多大呢
- 是否该为所有未确认的报文段各自设置一个定时器？

##### 估计往返时延

- 报文段的样本RTT（SampleRTT）就是从某报文段**被发出**到**对该报文段的确认被收到**之前的时间量
- 大多数tcp的实现**仅在某个时刻做一次sampleRTT的测量**，而不是为每个发送的报文段测量一个SampleRTT，也就是，在任意时刻。仅为一个已发送但未确认的报文段估计SampleRTT，从而产生一个接近每个RTT的新的sampleRTT
- tcp**不为已重传的报文段计算SampleRTT**（已重传的报文段收到ack，无法确认ack是对第一次发送的报文段的ack还是对重传的报文段的ack）
- 由于路由器的拥塞和端系统负载的变化，SampleRTT也会随之波动，所以任何给出的SampleRTT都是非典型的
- 为了估计一个典型的RTT，要采取某种对SampleRTT取均值的方法
  - tcp维持一个SampleRTT均值（称为EstimatedRTT 估计RTT）
  - 一旦获得一个新的SampleRTT，tcp就会根据公式更新EstimatedRTT
    - EstimatedRTT = (1-α)\*EstimatedRTT + α\*SampleRTT
    - EStimatedRTT由之前的EstimatedRTT和SampleRTT加权组成
    - α的参考值是0.125
  - RTT偏差：DevRTT，用于估算SampleRTT一般会偏离EstimatedRTT的程度
    - DevRTT = (1-β) \*DevRTT + β\*|SampleRTT-EstimatedRTT|
    - β的推荐值为0.25
    - 如果SampleRTT的波动较大，那么DevRTT的值会较大，反之亦然

##### 设置和管理重传超时间隔

- 假设已经给出了EstimatedRTT和DevRTT，那么tcp超时间隔该用什么值呢
- 超时间隔应大于EstimatedRTT，不然会产生不必要的重传，但是也不应超过EstimatedRTT太多，否则当报文丢失时，等待较长时间才能重传
- 要求将超时间隔设为EstimatedRTT加上一个余量
  - 假如DevRTT值较大，这个余量应该大些，反之亦然
- 时间间隔TimeoutInterval = EstiamtedRTT + 4\*DevRTT;

##### 可靠数据传输

tcp的可靠数据传输服务保证一个进程从其接收缓存中读出**非损坏的、无间隔的、非冗余的和按序**的**数据流**

- 定时器
  - 在之前的描述中，**每个已发送但未确认的报文段都有一个与之关联的定时器**
    - 这在概念上最简单
    - 但定时器的管理需要**很大的开销**
    - 因此，推荐的定时器管理过程仅适用**单一的定时器**
- 简化描述
  - 发送方的三个重传的主要事件
    - 从上层接收数据，封装到报文段，交给ip层；
      - 报文段的序号为第一个数据字节
      - 如果此时定时器还没有为其他报文段运行，则当次报文段被发送给ip时，启动计时器（保证计时对象为第一个发送且为确认的数据报）
      - 定时器的超时间隔是TimeoutInterval
    - 超时重传：滑动窗口+GBN
      - 具体实现在下方“tcp是GBN还是RS”
    - 来自接收方的确认的到来
      - 根据确认序号的值与base关系，不同处理
        - 特别的，tcp接收方是**积累确认**的
        - 假如收到了序号为20的，却没有收到序号为10的，那么确认序号应该是10，超时需要重传②
        - 假如发送方收到了20的确认，那么表面20之前的报文段按序接收
        - **因为积累确认，所以 收到一个在[base, base+N-1]的ack，可以知道ack之前的数据被正确接收，所以base推进到ack处，所以计时器需要重启**
      - 另外，如果当前有未被确认的报文段，tcp发送方还要重启计时器

- 大多tcp实现中的一些改动
  - 加倍超时间隔
    - 每次超时事件发生，超时间隔设置为当前值的2倍
    - 假如发送方发生了另外两个事件（接收到上层的数据、接收到接收方ack），根据EstimatedRTT和DevRTT重置超时间隔
    - 这样提供了一个有限的拥塞控制
  - 快速重传
    - 假如发送到收到连续3个相同的冗余的确认，就**快重传**，即在该报文段的定时器过期之前重传丢失的报文段（**为什么**）
  - tcp是GBN 还是 SR
    - tcp是一个混合了GBN和SR的协议
    - tcp是**积累确认**的，**正确但是失序的报文段不会被确认**，因此tcp发送方只需维持send_base和nextSeqNum
    - 但是tcp接收方**会缓存失序的报文段**（尽管不发送确认）
    - 分组n超时时，**并不会重传n以后的分组**，**至多重传分组n**
    - 发送方接收到分组n的确认，说明n之前的分组被正确接收

#### 流量控制

- 一条tcp连接的双方主机都会为该连接设置**接收缓存**(rcvBuffer 与窗口不同吗)，tcp连接收到正确、按序的报文段之后，会将数据放入接收缓存，相关联的进程从缓存中读取数据，如果发送方数据太多，可能使接收缓存溢出
- 流量控制目的是消除发送方使接收方缓存溢出的可能
- 接收方
  - tcp通过让发送方维护一个称为接收窗口（rcvWindow）的变量来提供流量控制，通过tcp首部由接受方发送给发送方
  - 定义两个变量
    - lastByteRead：接收方进程从缓存读出的数据流的最后一个字节的编号
    - lastByteRcvd：从网络中到达并已放入接收方接收缓存中的数据流最后一个字节的编号
  - rcvWindow = rcvBuffer - (lastByteRcvd-lastByteRead);
- 发送方
  - 发送方主机跟踪lastByteSent和lastByteAcked
  - 而两个变量差值就代表这已发送但未确认的数据量（这是不是发送窗口）
  - 发送方通过确保差值在rcvWindow以内，就可以确保发送方不会使接收方缓存溢出
- 当接收方缓存已经存满，0窗口（计算机网络（谢希仁）P227）
  - 当窗口变为非0时，可能接收方向发送方发送一个**接收窗口**字段值为非0的报文段，但这个报文段丢失了，那么接收方就和发送方一直等待着，形成死锁
  - 解决上述问题，tcp为每个连接设有一个**持续计时器**。只要tcp连接的一方收到对方的0窗口通知，就启动持续计时器
  - 若持续计时器超时，就发送一个**0窗口检查报文段（仅有1字节数据）**，而接收方在确认这个报文段时给出现在的窗口值
  - 如果窗口值仍为0，那么重启持续计时器，直到非0

#### tcp连接管理

##### 三次握手

- ![](pic/三次握手.png)

- 客户端的tcp首先向服务器端的tcp发送一个特殊的tcp报文段
  - 该报文段不包含应用层数据
  - SYN置为1，所以报文段被称为SYN报文段
  - 选择一个初始序号x，并加到这个SYN报文段中
  - 封装为数据报，交付ip层，发送到服务端
  - 客户端由closed进入syn-sent
- 客户端的SYN报文段到达服务端
  - 为该tcp连接分配tcp缓存（接收缓存）和变量（状态变量）
  - 并向客户端发送允许连接的报文段
    - 这个报文段也不包含数据
    - SYN被置为1、确认号x+1、选择自己的序号y
    - 这个报文段被称为SYNACK报文段
  - 服务器开始运行时由closed进入listen
  - 而接收到客户端syn请求连接建立报文时，由listen进入syn-rcvd
- 客户端收到SYNACK报文段
  - 给连接分配缓存和变量
  - 客户端向服务器发送另一个报文段
    - 对服务器允许连接的报文段进行确认，确认序号为y+1
    - 序号为x+1
    - 连接以建立，所以SYN置为0
  - 客户端进入established状态
  - 当服务器接收到此报文，也进入established状态
- 为什么要最后确认呢
  - 为了防止已失效的连接请求报文突然又传送到了B，而产生错误
  - 可能A向B发出连接请求，但请求超时了，之后重发了连接请求，而A与B通信结束之后，A第一次发出的连接请求到达了B。
  - 假如不需要最后一步确认的话，上面的情况下连接就建立了，这样浪费了服务端资源

##### 四次挥手

- ![](pic/四次挥手.png)
- tcp连接的两方都可以终止连接，假设客户端终止连接，终止连接前，两方状态都是established
- 客户端发送一个tcp报文段，FIN置为1，序号为u，**客户端进入fin-wait-1**
- 服务端收到这个报文段，向客户端发送一个确认报文段确认自己收到该报文段：**ACK为1，确认号为u+1，序号为v**；服务端进入**close_wait**（此时服务端可能仍有数据未传输完，服务端可以发送数据，接收方只能接收数据），客户端收到服务端的确认报文之后，进入fin-wait-2状态
- 当服务器没有要传输给客户端的数据时，就可以释放连接了：
  - 服务器发出**连接释放报文段**，**FIN为1，ACK为1，序号为w，确认号为u+1**，**服务端进入last-ack**
- 客户端收到连接释放报文段后，发送对此报文的确认：
  - **ACK为1，seq为u+1，ack为w+1**，**进入time_wait状态**，
  - 必须经过time-wait计时器设置的2MSL（最长报文寿命）时间后，客户端才进入closed状态
    - 为了保证客户端发送的最后一个确认报文段能够到达服务器
      - 因为客户端的确认可能丢失，而服务端等待确认超时的话，会重传连接释放报文段，接着客户端重传确认，并重启time-wait计时器
    - 防止出现**已失效的连接请求报文段**
      - 经过2MSL的时间，可以使当前连接的所有报文段失效，避免之前丢失的报文段突然被接收方收到
  - 而服务端收到客户端发送的确认之后可以直接进入closed状态

##### tcp状态转换

- 客户端 ![](pic/tcp状态转换-client.png)
- 服务端 ![](pic/tcp状态转换-server.png)

#### 拥塞控制

tcp有**两个关键部分**：其一：可靠传输；其二：**拥塞控制**

tcp的实现方法是让每个发送方根据所感受到的网络拥塞的程度，来限制其能向连接发送数据的速率；如果发送方感知在该路径上有拥塞，那么降低其发送速率，反之亦然

- 发送方如何限制其发送速率
  - tcp连接的每一端有**发送缓存**，**发送缓存的大小决定了发送的速率**
  - 拥塞机制保存了一个变量：**拥塞窗口**（congestion window）
  - 发送方未确认的数据量（即发送窗口大小）**不能超过congWin和RcvWInd的最小值**
  - 减小拥塞窗口即可控制发送速率
- 如何感知是否拥塞
  - 丢包的定义：
    - 出现超时
    - 收到来自接收方的3个冗余确认（说明接收到了3个失序的报文段，积累确认）
  - 当出现丢包的情况就认为是出现拥塞
- 当感知到拥塞之后，该怎样降低速率/拥塞控制算法
  - 加性增、乘性减/拥塞避免
    - 当出现丢包情况，拥塞窗口减半
    - 当收到新的确认时，每次把拥塞窗口增大一点
      - 假设初始窗口大小size，窗口内的报文段是n个，MSS为固定值
      - 每次接收到ack，窗口大小增加MSS/n的大小
      - 假如窗口内的报文段全部被确认，窗口大小刚好会增加MSS
  - 慢开始
    - tcp连接开始时，congWin的值初始置为1个MSS
    - 假如线性增长，增速太慢
    - 所以刚开始的时候，congWin指数增长
      - 每过一个RTT（这里是指窗口内从**第一个分组发出**到**最后一个分组被确认**的时间）将congWin翻倍
      - 假设初始窗口大小size，窗口内的报文段是n个
      - 每收到一个ack，将窗口增大size/n
      - 这样收到窗口内所有报文段的确认之后，窗口刚好翻倍
      - **这样真的是翻倍吗？size不是每收到一个确认会增大吗，size/n也会是一直增大呀（也许size保存的之前的size？？？很难实现呐）**
  - 刚开始时使用慢开始，到了一定情况下，开始使用拥塞避免算法
    - 设置一个慢开始门限ssthresh，初始值很大（实际中为65kB），以使它初始时没有意义（因为可能达不到慢开始门限就会出现拥塞）
      - 当congWIn < ssthresh：使用慢开始算法
      - 当congWIn > ssthresh：停止使用慢开始，而使用拥塞避免
      - 相等时，随意
    - 假如在慢开始的过程中发生了超时，
      - ssthresh置为congWin/2，窗口置为1
      - 开始使用慢开始
    - ![](pic/慢开始和拥塞避免.png)
  - 快重传和快恢复
    - 当收到3个重复确认（即使4个相同确认号，后三个是重复的），说明是个别报文段发生了丢包，而不是网络拥塞
      - 比如发生M1, M2, M3, M4, M5 这5个报文段，除M2丢失，其他的正确接收
      - M1收到会发送针对M1的确认（M2的第一个数据字节序号），
      - 而收到M345的时候，因为积累确认，也会发送一样的确认
      - 这时就是3个重复ack
    - 此时假如误以为网络拥塞，进行慢开始算法，传输速率降低
    - 而快重传快恢复算法可以解决这种情况
      - 快重传：当收到3个重复ack时（ack之前的数据正确收到），立即重传丢失的报文段（M2）
      - 快恢复：此时ssthresh仍被置为congWin/2，但congWin不是被置为1，而是置为ssthresh，并开始拥塞避免算法
      - 快重传和快恢复是一个整体，一起使用