### kmp

#### kmp 字符串匹配算法

1.  s1为原字符串，长n，s2为目的字符串长度m，n>=m，想在s1中找到连续的n2
2.  **n*m级别**的基本算法：从s1第**i**位开始，检查接下来的m位是否与s2相同，相同匹配成功，否则接着从**i+1**开始继续匹配m个字符。
3.  kmp算法目的是，第**i**次匹配可以使用**i-1次匹配失败的结果**
   1. 假如当前s1匹配到c1处,s2匹配到c2处，尝试复用c2之前的匹配结果，s2的前c2个字符串是与s1往前c2长的字符串相同的；
   2. 假设s2的前c2位中，前**j**个字符与后**j**个字符相同（最长前缀与最长后缀匹配——最多前j个字符与后j个字符相同），那么就可以从s1的c1处接着匹配s2的j处；c2从0到m-1，需要保存对应的j，这就是next数组，目标字符串才有next数组
4.  next数组求法，s位目标串
   1. next[0]为-1，标志着到了第0位（下面需要可以判断是否到了next的边缘），next[1]为0，表示当1处的字符不匹配，应该从0处开始重新匹配
   2. 从next[2]开始，使用next[0-i]的值计算next[i]：
      1. next[i]表示，s中**第0到next[i]-1这next[i]位字符**与**i往前数next[i]位的字符**匹配，
      2. 若**i+1**的值等于**next[i]+1**，则next[i+1]等于next[i]+1(**第i+1位的最长前后缀为第i位加一**)
      3. 否则查看**next[next[i]]+1**处字符是否与**i+1**处相同，这样next[i+1]为next[next[i]]+1
      4. 循环3，直到一直找到0处，这时next[i+1]为0

#### kmp jdk 实现 string的split方法

n^2级别的算法

### Manacher 回文串算法

1. 因为回文串可能有奇数个字符，也有可能有偶数个字符，奇数个字符时，处理较简单，找到轴往两边扩展就可以，而偶数个的轴有两个；所以，首先将字符串中每个字符之间插入#，那么原字符串就会变成奇数个字符。
2. 基本的求解回文串的方法：以一个字符为轴向两边扩展，两字符就继续扩
3. 基本的算法，求解i处的回文串是无法使用i之前的结论的，而manacher的快速正是因为可以基于之前的结果快速给出当前结果：
   1. 记录已求字符到达的最右边界**R**及此时的轴**center**，初始时都是-1
   2. 求第**i**个字符开始求回文串：
      1. 如果**i**在**R**之外或者i恰好在**R**上，暴力求解（从当前位开始往两边扩）
      2. 如果在**R**界内，求出**i**对于**center**的对称点**j**，**j**必定在已被求解过，需要讨论**j**处的结果是否对**i**有用：
         1. 若**j**处的回文串**小于左界**，即**j**处的回文串在当前**R界和center标志的回文串中**，那么**i处的回文串大小等于j处**，

         2. 若**j**处的回文串**大于左界**，即**j**处的回文串**一截**在当前**R界和center标志的回文串中**，**另一截在左界的外面**，那么**i处的回文串大小等于i距离右界的距离**（原因：在左界外面的部分**不等于（不能构成回文串）**在右界外的部分，而左界内的部分**等于**左界外的部分，**所以右界内不等于右界外，右界内的部分无法扩展出界外，只能刚好到右界**）

         3. 只有当**i恰好在右界上**，i才有可能往外扩，需要暴力求解
