# 创建型模式

## 简单工厂

**定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。**

三类实体：工厂、抽象产品、具体产品

#### 优点：

1. 工厂类包含必要的判断逻辑，通过传入参数决定什么时候创建哪种具体产品，客户端无需直接创建产品，仅消费；实现对象的创建和使用的分离
2. 无需知道具体产品类名，只需产品的参数，低耦合

3. 引入配置文件，可以在不修改 **客户端**代码的情况下，更换和增加具体产品类，提高系统灵活性。（修改配置文件，客户端读取配置文件中产品属性；不过增加或修改产品类时，依旧需要修改具体工厂的方法，因为创建产品的方法包含逻辑）

#### 缺点：

1. 工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都收到影响。
2. 扩展困难，添加新产品必须修改工厂逻辑，产品过多时，工厂逻辑复杂。不利于系统扩展、维护。
3. 简单工厂因为创建方法为静态方法，工厂类无法继承进行扩展。

#### 适用场景：

1. 工厂负责创建的对象比较少。
2. 客户端只知道工厂的参数，对如何拆个那就对象不关心。

## 工厂方法
定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。工厂方法模式又简称为工厂模式(Factory Pattern)，又可称作虚拟构造器模式(Virtual Constructor Pattern)或多态工厂模式(Polymorphic Factory Pattern)。工厂方法模式是一种类创建型模式。

四类实体：抽象产品、具体产品、抽象工厂、具体工厂

客户端通过选择实例化不同的具体工厂（客户端须自己实力化具体工厂），使用具体工厂的创建方法创建不同的具体产品

#### 优化的工厂方法（配置文件）

将具体的工厂类的类名写入配置文件，客户端读取配置的工厂类名，运用**java反射**通过类名获得具体工厂实例，再由工厂生成具体产品；

而需要增加产品工厂及产品时，只需要新继承抽象产品、抽象工厂，并修改配置文件就可以实现。

#### 优点：

1. 客户端只需要关心工厂，无需关心创建细节，以及具体产品类的类名
2. 工厂和产品的多态性，让工厂可以自主确定创建何种产品对象（抽象工厂有多种实现，具体工厂创建时，又可以通过不同类型参数进行方法重载），创建细节隐藏。
3. 加入新产品时，只需要添加一个具体工厂和具体产品就可以了，系统扩展性好，完全符合”开闭原则“。

#### 缺点：

1. 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。

2. 需要引入抽象层，客户端代码使用抽象层实现，增加系统抽象性和理解难度，引入dom、反射增加系统实现难度。

#### 适用场景：

## 抽象工厂

**提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，它是一种对象创建型模式。**

抽象工厂：声明了一组用于创建一族产品的方法，每一个方法对应一种产品

具体工厂：实现了抽象工厂声明的创建产品的方法。

抽象产品、具体产品

#### 抽象工厂与重载的工厂区别：

- 重载的工厂：一个工厂生产产品的方法名是相同的，通过重载生成不同的产品
- 抽象工厂：一个工厂生产产品的方法不同

#### 优点：

1. 同一个工厂可以创建一族产品，类的个数下降。
2. 更换一个工厂，就可以同时更换一族产品。
3. 可以通过添加新的具体工厂，可以添加一族产品，扩展方便（所以，可以将易出现扩展的方向，由具体工厂的不同来实现）

#### 缺点：

1. 想在抽象工厂中添加一列产品很难，需要修改抽象工厂，所有的具体工厂，扩展性差

## 单例

## 原型

## 建造者

# 结构型模式

## 适配器

## 桥接

## 组合

## 装饰

## 外观

## 享元

## 代理

# 行为模式

## 职责链

## 命令

## 解释器

## 迭代器

## 中介者

## 备忘录

## 观察者

## 状态

## 策略

## 模板方法

## 访问者